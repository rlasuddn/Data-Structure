/**
 * 프로그래머가 배열을 선언할때 배열의 크기를 선언한다. int[10] = {1,2,3,4,5}
 * 운영체제는 메모리에 10개의 값이 연속적으로 들어갈 빈 공간을 찾아서 값을 넣는다.
 * 운영체제는 배열의 첫번째 주소만을 기억한다.
 * 두번째 값에 접근하려면 arr[1]로 한번에 접근
 * 배열의 시작 주소를 알고 있기 때문에 시작 주소에서 1번 떨어진 값을 가져온다.
 * 배열의 인덱스 참조는 길이에 상관없이 한번에 가져오기 때문에 O(1)의 성능을 진다.
 * 이러하여 배열은 읽기/쓰기, 참조에서 좋은 성능을 보인다.
 *
 * 단점
 * 처음 10인 길이의 배열을 선언 후 값을 추가 및 삭제하려면
 * 연속된 메모리 주소를 할당하여야 하는데 처음 할당했던 메모리 주소 다음 주요한 데이터가 있다면 운영체제는 다시 해당 길이의 맞는 메모리 주소를 찾아야한다.
 * 그래서 처음 할당된 값 또한 메모리 주소가 변경됨에 따라 새로 복사를 해야한다.
 * 배열은 추가/제거를 하려면 내부적으로 필요한 단계가 많아 성능이 좋지 않다.
 */

/**
 * js에서 배열
 * js는 처음 배열의 길이를 할당하지 않는다.
 * push(),pop() 함수로 추가/제거가 가능하다.
 * js에서는 배열을 대부분 불연속적으로 메모리를 할당한다.
 * 내부적으로 해당 값들을 연결하여 사용자에게 배열인 것처럼 보인다.
 * 자료구조의 기능적으로만 봤을땐 동일하여 배열이라 부를 수 있다.
 */

/**
 * 정리
 * 배열은 읽기, 쓰기와 같은 참조에는 O(1)의 성능을 가진다.
 * 크기 예측이 힘들기 때문에 메모리 낭비가 발생할 수 있고, 데이터 삽입, 삭제가 비효율적이다.
 */
