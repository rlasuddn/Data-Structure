/**
 * 일반적으로 알고리즘의 속도를 성능의 척도로 사용한다
 * 시간 복잡도: 특정 알고리즘이 해결하는 데 걸리는 시간
 * 컴퓨터의 성능에따라 시간은 달라진다 그러므로 코드에서 성능에 많은 영향을 주는 부분(반복문)을 찾아 실행시간을 예측한다.
 *
 */

/**
 * 주어진 배열에서 5를 찾으시오.
 * [1,2,3,4,5]
 * 최선의 경우 한번에 찾음, 최악에 경우 배열의 길이만큼 걸림, 평균의 경우 배열의 길이 중간 만큼 걸림
 * 최선의 경우는 Big-Ω, 최악의 경우는 Big-O, 평균의 경우는 Big-Θ
 */

/**
 * 배열의 길이가 4라면 최악의 경우 4번 만에
 * ~ 5라면 최악의 경우 5번만에
 * ...
 * 배열의 길이가 n이라면 최악의 경우 n번 만에, => (최악의 경우는 Big-O표기법 이용) O(n)
 * n=1 이면 계산량은 1 n=2 면 계산량은 2 데이터가 많아지면 계산량이 증가한다. 이러한 이유로 O(n)의 알고리즘은 선형시간 알고리즘이라고 부른다.
 */

/**
 * 상수시간 알고리즘
 * 입력(데이터 수)의 크기에 상관없이 상수의 시간이 걸린다. => O(1)
 * 입력의 크기에 상관없이 100번의 계산이 걸린다고 해도 상수이기 때문에 O(1)
 * 때문에 빅오 표기법은 정확한 성능을 계산하지 못한다.
 * 입력에 따라 계산량이 얼마나 늘어나는지 표현하는 방법이기 때문.
 */

/**
 * 빅오 표기법 특징
 * n² + 2n + 100의 성능인 알고리즘의 표기 법은 계산에 가장 영향이 미치는 항만 표현한다. => O(n²)
 * 3n² + 100n => O(3n²)
 * 상수는 큰 의미가 없으므로 상수는 제거한다. O(3n²) => O(n²)
 */
